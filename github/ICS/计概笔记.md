# Two major themes

abstraction：提供便利，但是也要了解内部细节

```
eg:taxi
```

 

hardware vs software

不可分割的



CPU I/O MEM

所有电脑的计算性能一致，只要给足够多的时间空间，性能好的电脑能解决的问题性能差的电脑也能解决。

Problem：

二义性，ambiguity，模糊性，要转化为算法

algorithm：

三大特性： 

明确性：

可执行性:

有穷性:

algorithm 转化成program 

高级 C 

低级 汇编器进行编译

指令集 ISA

操作符 数据类型 寻址模式

转化成微架构 ： 指令集的实现方式

一个ISA可以对应多个微架构

一个微架构只能对应一个ISA

逻辑电路

电子电路Electric Circuit

电子Electriction

# BITS DataType 

无符号整数 在相加的时候会发生溢出 

Signed integer 

Signed Magnitude 最高位作为符号位

1's complement

bit vector 表示性质的存在或者不存在 m位表示m位的状态

使用OR 1 设置存在

使用AND 0 设置不存在

使用AND 1进行查询

ASCII码八位二进制 1byte

十六进制表示 防止Copy错误 转化为16进制



PN结 上并联下串联 上串联下并联

NOT 门

![image-20230713150739046](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230713150739046.png)

考虑对称性，只讨论In = 1 的情况， IN =1 时 ， 上面阻塞 所以OUt =0

NOR 门

设计思路，NOR的含义是 当AB都是0的时候为1

所以要求P串联，AB两个为0都导通，才能是1

![image-20230713150914645](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230713150914645.png)

![image-20230713150924182](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230713150924182.png)

对NOR取反我们得到了OR门，因为NOR上面P是串联的，所以NOR下面的N的是并联的



为什么不能直接使用如下图![image-20230713151011585](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230713151011585.png)



Question

Compiler

1. 将高级语言转化为ISA的工具 VS 高级语言转化为汇编的工具 Compiler有两层功能，一个是phase，中间态，第二层就是将中间语言优化，减少指令数量，以书上指令为主。
2. 实现了部分功能的microarchitecture 一个微架构实现了部分功能， 你选择的这些功能构成了该微架构的ISA

# CH2

十六进制

4bit作为整体，整数从低位开始连续4bit 小数是从小数点后开始转化

八进制

3bit作为整体，整数部分从地位开始3bit,小数点后开始

十进制

转化 加权

转化为X进制，短除法

德摩根定理 Demorgan'law

浮点数转化

float  exp 

最小的正数 1.0* 2^127

* (2-2^-23)2^-126

exp = 255 fraction = 0 INF 

exp = 255 fraction != 0 NaN

非规格化数字

exponent=0，fraction != 0

N = (-1)*0.fraction * 2^-126 1<= exp <= 254

exp =0 frac = 0 视为0

非规格化值：exp全为0时，e为0，但是指数E=1-bias（而非0-bias，为了平滑过渡，通过增加一个1，可以弥补非规格化数frac最高位没有的1），此时frac最高位为0，不为默认的1.好处1可以表示0，好处2可以表示接近0的数

# Ch3

Transistor

N Type P type

Drain在上 Source在下 对于 Ntype 需要放下面 表示什么情况下阻塞

source在上 Drain在下 对于 Ptype 需要放上面 表示什么情况下连同

Decoder

Mux Decoder + Or

是用真值表 实现逻辑电路 也就是列出三元ABC的八种可能 然后按照sigma连线

四位加法器 四个全加器串联 右边导0

Programming logical array

需要链接的逻辑 在Connections处进行连接

logical Completeness 与或非是逻辑完备的，能够使用这三种门造出全部的组合逻辑电路

NAND    

x NAND x = F

x NAND F = T 

x NAND T = NOT x



RS latch

使用NAND实现

| R    | S    | Stats         |
| ---- | ---- | ------------- |
| 1    | 1    | 保持          |
| 1    | 0    | Reset ，置位0 |
| 0    | 1    | Set 置位1     |
| 0    | 0    | 未定义状态    |

 

Dlatch

加入写使能信号

也就是在WE为1的时候才能进行操作

假设D是1 WE是1 NAND为0 R=0 进行Set 1 操作

反之 D= 0 WE水1 NAND为 1 R=1 进行Reset 0

使用解码器解码地址线A[1:0] 信息都存在Dlatch 之中

 输入一个地址 比如 00 那么需要找到位于第一行的向量信息 得到D2 D1 D0 使用与门获得数据

加入一根写使能线WE ，只有WE的时候才能够进行写操作



地址空间 Address sapce 

当前地址能够定义的地址总数，始终看地址线，即便是不存在解码器

寻址能力 Address ablility

一个地址对应了多少位的内容，也就是访问一个地址能够得到多少bit 的数据





# FSM

有限状态机 Finite State  Machine

输出和当前状态和输入有关 计概讨论的是Mealy型状态机

时序逻辑电路，组合逻辑用于计算输出，存储模块保存当前状态，当前状态和input共同作为输出，输出作为存储模块的输入

同步的有限状态机

Synchronous Finite State Machine 同步的，使用时钟控制的

Asynochronous 异步的

Danger Sign 同步的有限状态机

组合逻辑电路的设计 PLA，画真值表然后设计 省略decoder之中没有的输出

由当前状态画出下一状态

flip flop 主从触发器

问题 因为使用gate Dlatche  Transparent 组合逻辑会立刻反应到存储的输入

所以需要链接两个Gate Dlatch 同时接入一个时钟的信号

左边的是Master 右边是Slave

始终让这两个只有一个能写，第一个SR不可写 

# Ch4 Von Neumann Model

IO MEM CPU

Processing unit 

ALU  TEMP CONTROL UNIT

MAR读取地址 MDR读出读入数据 TEMP 

 Control Unit PC Program Counter IR instruction register

使用寄存器暂存结果提高运算速度

每个寄存器可以存16bit 的值

指令和数据存放在一起

PC 指令的地址

IR  指令的内容



ADD

0001 【5】0 使用Reg 1 使用imm DR SR1 0 00 SR2

立即数是补码表示形式 五位 0001 DR SR1 1 imm5

AND

 0101 其他和ADD一样

LD

0010 DR imm9 PC是已经自增过一次的 

0000 nzp imm9

BR 4bit 0 

TRAP

1111 0000 八位TRAPVEC  x25



指令周期：

FETCH 至少七个时钟周期 一个时钟周期自增和送PC 5个周期取MAR 1一个周期给IR

DECODE 解码指令

EVALUATE ADDRESS LD指令访存 所以计算地址 PC和imm 加法 传给BUS 到MAR 一个时钟 接下来访存 五个周期 得到MDR，BR指令没有该步骤 ，因为它不是访存操作，这一步特指需要访存的PC计算

FETCH OPERAND 取操作数

EXECUTE 计算 特指ALU

STORE RESULT 存储结果



执行 写回其实是一个周期 如果是R操作 所以使用16bit Flip Flop



![image-20230715155337826](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230715155337826.png)

![image-20230715155854870](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230715155854870.png)

![image-20230715160042654](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230715160042654.png)![image-20230715160054893](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230715160054893.png)

![image-20230715160209478](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230715160209478.png)

LEA R2,DATA

LDR R4,R2,#0

DATA .FILL x008B

LEA将会吧DATA的内存地址交给R2寄存器，接下来LDR使用BASE+offset方式获得DATA中的地址，这将读到x008B 并交给R4

第二种方法(更费时间)

LDI R2,DATA

DATA .FILL x008B

LDI 将会获得DATA的地址，访问一次内存，得到其值，然后用读来的值作为DATA地址再读一次值 交给R2

区别在于 一个是把DATA的地址交给寄存器，一个是直接拿着DATA的地址读其值，然后以x008B作为地址，把x008B处的内容给R4，而不是把x008B这个地址本身交给R4

ldi r4,DATA ===

 r4 = *data // 

lea r2,DATA ldr r4,r2,#0 ldr r4,r2,#0 r4 = *data



lea r2,DATA  ldr r4,r2,#0===

 r4 = data

lea r2,DATA ===

r2 = &data

ADD instruction does not require a separate EVALUATE ADDRESS phase or
a separate STORE RESULT phase. The LC-3 LD instruction does not require an
EXECUTE phase. On the other hand, there are instructions in other ISAs that
require all six phases.

# Ch7

Label OPcode operands

opcode operands可以不同 但是必须要有

不写默认十进制 b二进制 x十进制

Pesudo OPs

.ORIG .END .FILL .BLKW .STRINGZ 占据的空间是字符串长度+1

EXTERNAL 声明外部变量 可以调用别的LABEL

执行过程： 建立symbol table

State Machine

![image-20230721195033688](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230721195033688.png)





![image-20230725142300943](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230725142300943.png)

Processor status register (PSR) A 16-bit register, containing status
information about the currently executing process. Seven bits of the PSR
have been defined thus far. PSR[15] specifies the privilege mode of
the executing process. PSR[10:8] specifies the priority level of the currently
executing process. PSR[2:0] contains the condition codes. PSR[2] is N,
PSR[1] is Z, and PSR[0] is P.

![image-20230725142350264](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230725142350264.png)

 privilege mode violation: 在用户模式下使用RTI指令

 processor attempts to execute the RTI instruction while
running in User mode

illegal opcode:使用1101 13号指令

 if the processor attempts to execute an instruction having the unused opcode (bits [15:12] =
1101)

access control violation:访问保护的内存

 the processor attempts to access privileged
memory

Exceptions are handled as soon as they are detected. They are initiated very
much like interrupts are initiated, that is:
1. The PSR of the process causing the exception is saved in TEMP.
    A.3 Interrupt and Exception Processing 677
2. The processor sets the privilege mode to Supervisor mode (PSR[15]=0).
3. If the process causing the exception is in User mode, R6 is saved in
    Saved USP and R6 is loaded with the SSP.
4. TEMP and the PC of the process causing the exception are pushed onto the
    supervisor stack.
5. The exception supplies its eight-bit vector. In the case of the privilege mode
    violation, that vector is x00. In the case of the illegal opcode, that vector is
    x01. In the case of the ACV exception, that vector is x02.
6. The processor expands that vector to x0100, x0101, or x0102, the
    corresponding 16-bit address in the interrupt vector table.
7. The PC is loaded with the contents of memory location x0100, x0101, or
    x0102, the address of the first instruction in the corresponding exception
    service routine.

![image-20230728112947998](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230728112947998.png)![image-20230728113038419](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20230728113038419.png)







